---
title: "ML_models"
format: html
---

# Libraries 
```{r}
#clear R environment
rm(list = ls())

# check for a package, install and load 
pkgCheck <- function(x){ 
  if (!require(x,character.only = TRUE)){
    install.packages(x,dependencies=TRUE)
    if(!require(x,character.only = TRUE)) {
      stop()
    }
  }
}

pkgCheck("sf")
pkgCheck("terra")
pkgCheck("dplyr")
pkgCheck("data.table")  # fast data.frame manipulation (used by mlr3)
pkgCheck("mlr3") # machine learning (see Chapter 12)
pkgCheck("mlr3spatiotempcv") # spatio-temporal resampling 
pkgCheck("mlr3tuning") # hyperparameter tuning package
pkgCheck("mlr3learners") # interface to most important machine learning packages
pkgCheck("paradox") # defining hyperparameter spaces
pkgCheck("ranger")  # rf package
pkgCheck("tree") # decision tree package
pkgCheck("readr")
pkgCheck("sp")
pkgCheck("raster")
pkgCheck("gbm")
pkgCheck("xgboost")
pkgCheck("caret") # for cohen's kappa calculation 
pkgCheck("pdp")
pkgCheck("gbm")
pkgCheck("Metrics")
pkgCheck("modEvA")
pkgCheck("tidyr")
```


# Load data 
```{r}
# Load data containing only v, and v + wd explanatory variables
data_v <- read_delim("Pre_Processing/abiotic_mi_sampling/lab_ml_v.csv") 
data_wd <- read_delim("Pre_Processing/abiotic_mi_sampling/lab_ml_wd_v.csv") 
data_sampling <- read_delim("Pre_Processing/abiotic_mi_sampling/lab_ml_sampling.csv") 
data_section <- read_delim("Pre_Processing/abiotic_mi_sampling/lab_ml_section.csv") 

# w/o hydr. models "GL1", "GL2", "L2", "M1", "S1", "S2", "TH4", "VR3"
# training set containing velocity 
training_v <- data_v |>
  filter(Reach_Untersuchungsstelle != "GL1",
         Reach_Untersuchungsstelle != "GL2",         
         Reach_Untersuchungsstelle != "L2",
         Reach_Untersuchungsstelle != "M1",
         Reach_Untersuchungsstelle != "S1",
         Reach_Untersuchungsstelle != "S2",
         Reach_Untersuchungsstelle != "TH4", # noch nicht im lab datensatz, darum wirds noch nicht eingerechnet
         Reach_Untersuchungsstelle != "VR3")

# training set containing velocity + wd
training_wd <- data_wd |>
  filter(Reach_Untersuchungsstelle != "GL1",
         Reach_Untersuchungsstelle != "GL2",         
         Reach_Untersuchungsstelle != "L2",
         Reach_Untersuchungsstelle != "M1",
         Reach_Untersuchungsstelle != "S1",
         Reach_Untersuchungsstelle != "S2",
         Reach_Untersuchungsstelle != "TH4", # noch nicht im lab datensatz, darum wirds noch nicht eingerechnet
         Reach_Untersuchungsstelle != "VR3")

# training set containing all env. variables measured at each sampling location 
training_sampling <- data_sampling |>
  filter(Reach_Untersuchungsstelle != "GL1",
         Reach_Untersuchungsstelle != "GL2",         
         Reach_Untersuchungsstelle != "L2",
         Reach_Untersuchungsstelle != "M1",
         Reach_Untersuchungsstelle != "S1",
         Reach_Untersuchungsstelle != "S2",
         Reach_Untersuchungsstelle != "TH4", # noch nicht im lab datensatz, darum wirds noch nicht eingerechnet
         Reach_Untersuchungsstelle != "VR3")

# w/ hydr. models 
# test set containing velocity 
test_v <- data_v |>
  filter(Reach_Untersuchungsstelle == "GL1" |
         Reach_Untersuchungsstelle == "GL2" |       
         Reach_Untersuchungsstelle == "L2" |
         Reach_Untersuchungsstelle == "M1" |
         Reach_Untersuchungsstelle == "S1" |
         Reach_Untersuchungsstelle == "S2" |
         Reach_Untersuchungsstelle == "TH4" | # fehlt noch im lab datensatz 
         Reach_Untersuchungsstelle == "VR3")

# test set containing velocity + wd
test_wd <- data_wd |>
  filter(Reach_Untersuchungsstelle == "GL1" |
         Reach_Untersuchungsstelle == "GL2" |       
         Reach_Untersuchungsstelle == "L2" |
         Reach_Untersuchungsstelle == "M1" |
         Reach_Untersuchungsstelle == "S1" |
         Reach_Untersuchungsstelle == "S2" |
         Reach_Untersuchungsstelle == "TH4" | # fehlt noch im lab datensatz 
         Reach_Untersuchungsstelle == "VR3")

# Prep data to model 
# TRAINING SETS
# With k_index as response variable & velocity 
training_v_k <- training_v |>
  dplyr::select(k_index, velocity, x, y)

# With shannon index as response variable & velocity 
training_v_s <- training_v |>
  dplyr::select(shannon, velocity, x, y)

# With abundance as response variable & velocity 
training_v_a <- training_v |>
  dplyr::select(abundance, velocity, x, y)

# With k_index as response variable & velocity + wd
training_wd_k <- training_wd |>
  dplyr::select(k_index, velocity, wd_cm, x, y)

# With shannon index as response variable & velocity + wd
training_wd_s <- training_wd |>
  dplyr::select(shannon, velocity, wd_cm, x, y)

# With abundance index as response variable & velocity + wd
training_wd_a <- training_wd |>
  dplyr::select(abundance, velocity, wd_cm, x, y)

# TEST SETS
# With k_index as response variable & velocity
test_v_k <- test_v |>
  dplyr::select(k_index, velocity, x, y) 

# With shannon index as response variable & velocity
test_v_s <- test_v |>
  dplyr::select(shannon, velocity, x, y) 

# With abundance as response variable & velocity
test_v_a <- test_v |>
  dplyr::select(abundance, velocity, x, y) 

# With k_index as response variable & velocity + wd
test_wd_k <- test_wd |>
  dplyr::select(k_index, velocity, wd_cm, x, y) 

# With shannon index as response variable & velocity + wd
test_wd_s <- test_wd |>
  dplyr::select(shannon, velocity, wd_cm, x, y) 

# With abundance as response variable & velocity + wd
test_wd_a <- test_wd |>
  dplyr::select(abundance, velocity, wd_cm, x, y) 

# convert dataframes into spatial objects for mlr3 spatial hyperparameter tuning 
# for k_index and velocity 
data_v_k_sp <-  st_as_sf(training_v_k, coords =  c("x", "y"))
st_crs(data_v_k_sp) <- "EPSG: 2056"

# for shannon index and velocity 
data_v_s_sp <-  st_as_sf(training_v_s, coords =  c("x", "y"))
st_crs(data_v_s_sp) <- "EPSG: 2056"

# for abundance and velocity 
data_v_a_sp <-  st_as_sf(training_v_a, coords =  c("x", "y"))
st_crs(data_v_a_sp) <- "EPSG: 2056"

# for k_index and velocity + wd
data_wd_k_sp <-  st_as_sf(training_wd_k, coords =  c("x", "y"))
st_crs(data_wd_k_sp) <- "EPSG: 2056"

# for shannon index and velocity + wd
data_wd_s_sp <-  st_as_sf(training_wd_s, coords =  c("x", "y"))
st_crs(data_wd_s_sp) <- "EPSG: 2056"

# for abundance and velocity + wd
data_wd_a_sp <-  st_as_sf(training_wd_a, coords =  c("x", "y"))
st_crs(data_wd_a_sp) <- "EPSG: 2056"
```


# Random Forest 
## Hyperparameter tuning 
### Create Task & Learner
```{r}
### ONLY VELOCITY AS PREDICTOR (& x, y for spatial hyperparameter tuning) ###
# create task for k_index and velocity
task_rf_v_k <- mlr3spatiotempcv::as_task_regr_st(data_v_k_sp,
  id = "velocity", target = "k_index")

# create task for shannon index and velocity
task_rf_v_s <- mlr3spatiotempcv::as_task_regr_st(data_v_s_sp,
  id = "velocity", target = "shannon")

# create task for abundance and velocity
task_rf_v_a <- mlr3spatiotempcv::as_task_regr_st(data_v_a_sp,
  id = "velocity", target = "abundance")

### VELOCITY + WD AS PREDICTORS (& x, y for spatial hyperparameter tuning) ###
# create task for k_index and velocity + wd
task_rf_wd_k <- mlr3spatiotempcv::as_task_regr_st(data_wd_k_sp,
  id = "velocity", target = "k_index")

# create task for shannon index and velocity + wd
task_rf_wd_s <- mlr3spatiotempcv::as_task_regr_st(data_wd_s_sp,
  id = "velocity", target = "shannon")

# create task for abundance and velocity + wd
task_rf_wd_a <- mlr3spatiotempcv::as_task_regr_st(data_wd_a_sp,
  id = "velocity", target = "abundance")

### LEARNER ###
# create learner for a random forest model from the ranger package
# for k_index, shannon index and abundance + velocity + wd valid
lrn_rf <- lrn("regr.ranger", predict_type = "response")

# performance estimation level
# perf_level <- mlr3::rsmp("repeated_spcv_coords", folds = 5, repeats = 100) # wo brauche ich das??
```

### Specify search space
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# specifying the search space for k_index and velocity
search_space_v_k <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_v_k$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

# specifying the search space for shannon index and velocity
search_space_v_s <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_v_s$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

# specifying the search space for abundance and velocity
search_space_v_a <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_v_a$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

### VELOCITY + WD AS PREDICTORS ###
# specifying the search space for k_index and velocity + wd
search_space_wd_k <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_wd_k$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

# specifying the search space for shannon index and velocity + wd
search_space_wd_s <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_wd_s$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

# specifying the search space for abundance and velocity + wd
search_space_wd_a <- paradox::ps(
  mtry = paradox::p_int(lower = 1, upper = ncol(task_rf_wd_a$data()) - 1),
  sample.fraction = paradox::p_dbl(lower = 0.2, upper = 0.9),
  min.node.size = paradox::p_int(lower = 1, upper = 10)
)

# num.trees noch suchen? 
```

### Hyperparameter tuning 
resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning # gibt kein richtig, falsch, je mehr folds desto mehr modelle müssen trainiert werden
```{r}
### VELOCITY AS PREDICTOR ###
# with k_index and velocity 
autotuner_rf_v_k <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning  (rechenintensiver), 5 ist relativ üblich 
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_v_k, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# with shannon index and velocity 
autotuner_rf_v_s <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_v_s, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# with abundance and velocity 
autotuner_rf_v_a <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_v_a, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

### VELOCITY AND WD AS PREDICTORS ###
# with k_index and velocity + wd
autotuner_rf_wd_k <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_wd_k, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# with shannon index and velocity + wd
autotuner_rf_wd_s <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_wd_s, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# with abundance and velocity + wd
autotuner_rf_wd_a <- mlr3tuning::AutoTuner$new(
  learner = lrn_rf,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_wd_a, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)
```

```{r}
# set seed to obtain the same results with each run
set.seed(0412022)

# hyperparameter tuning
### VELOCITY AS PREDICTOR ###
# k_index and velocity 
autotuner_rf_v_k$train(task_rf_v_k)

# shannon index and velocity 
autotuner_rf_v_s$train(task_rf_v_s)

# abundance and velocity 
autotuner_rf_v_a$train(task_rf_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
autotuner_rf_wd_k$train(task_rf_wd_k)

# shannon index and velocity + wd 
autotuner_rf_wd_s$train(task_rf_wd_s)

# abundance and velocity + wd
autotuner_rf_wd_a$train(task_rf_wd_a)
```


```{r}
# read the results 
### VELOCITY AS PREDICTOR ###
# for k_index and velocity
autotuner_rf_v_k$tuning_result

# for shannon index and velocity
autotuner_rf_v_s$tuning_result

# for abundance and velocity
autotuner_rf_v_a$tuning_result

### VELOCITY + WD AS PREDICTORS ###
# for k_index and velocity + wd
autotuner_rf_wd_k$tuning_result

# for shannon index and velocity + wd
autotuner_rf_wd_s$tuning_result

# for abundance and velocity + wd
autotuner_rf_wd_a$tuning_result
```

## RF Model
### Prep Data w/o Coordinates
x und y coord müssten meines Wissens nach nicht drin sein weil sie nur für das tuning verwendet wurden
kein grosser Unterschied der Model performance wenn x, y drin oder draussen sind
```{r}
### TRAINING SETS ###
# With k_index as response variable & velocity 
training_v_k <- training_v |>
  dplyr::select(k_index, velocity, x, y)

# With shannon index as response variable & velocity 
training_v_s <- training_v |>
  dplyr::select(shannon, velocity, x, y)

# With abundance as response variable & velocity 
training_v_a <- training_v |>
  dplyr::select(abundance, velocity, x, y)

# With k_index as response variable & velocity + wd
training_wd_k <- training_wd |>
  dplyr::select(k_index, velocity, wd_cm, x, y)

# With shannon index as response variable & velocity + wd
training_wd_s <- training_wd |>
  dplyr::select(shannon, velocity, wd_cm, x, y)

# With abundance index as response variable & velocity + wd
training_wd_a <- training_wd |>
  dplyr::select(abundance, velocity, wd_cm, x, y)

### TEST SETS ###
# With k_index as response variable & velocity
test_v_k <- test_v |>
  dplyr::select(k_index, velocity, x, y) 

# With shannon index as response variable & velocity
test_v_s <- test_v |>
  dplyr::select(shannon, velocity, x, y) 

# With abundance as response variable & velocity
test_v_a <- test_v |>
  dplyr::select(abundance, velocity, x, y) 

# With k_index as response variable & velocity + wd
test_wd_k <- test_wd |>
  dplyr::select(k_index, velocity, wd_cm, x, y) 

# With shannon index as response variable & velocity + wd
test_wd_s <- test_wd |>
  dplyr::select(shannon, velocity, wd_cm, x, y) 

# With abundance as response variable & velocity + wd
test_wd_a <- test_wd |>
  dplyr::select(abundance, velocity, wd_cm, x, y) 
```

### Make models 
```{r}
# Create and train the random forest model with only velocity
# VELOCITY AS PREDICTOR
# for k_index and velocity
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.2059293            10          <list[4]> <list[3]> 0.1413796
rf_model_v_k <- ranger(formula = k_index ~., data = training_v_k, mtry = 1, sample.fraction = 0.2059293, min.node.size = 10)

# for shannon index and velocity
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.2426534             7          <list[4]> <list[3]> 0.5703676
rf_model_v_s <- ranger(formula = shannon ~., data = training_v_s, mtry = 1, sample.fraction = 0.2426534, min.node.size = 7)

# for abundance and velocity
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.3763677             9          <list[4]> <list[3]>  741.6989
rf_model_v_a <- ranger(formula = abundance ~., data = training_v_a, mtry = 1, sample.fraction = 0.3763677, min.node.size = 9)

# Create and train the random forest model with velocity + wd
# VELOCITY + WD AS PREDICTORS 
# for k_index and velocity + wd
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.2451874             9          <list[4]> <list[3]> 0.1371224
rf_model_wd_k <- ranger(formula = k_index ~., data = training_wd_k, mtry = 1, sample.fraction = 0.2451874, min.node.size = 9)

# for shannon index and velocity + wd
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.2019869             6          <list[4]> <list[3]> 0.5556115
rf_model_wd_s <- ranger(formula = shannon ~., data = training_wd_s, mtry = 1, sample.fraction = 0.2019869, min.node.size = 6)

# for abundance and velocity + wd
#   mtry sample.fraction min.node.size learner_param_vals  x_domain regr.rmse
#1:    1       0.2068668             5          <list[4]> <list[3]>  730.9148
rf_model_wd_a <- ranger(formula = abundance ~., data = training_wd_a, mtry = 1, sample.fraction = 0.2068668, min.node.size = 5)
```

## Evaluation Metrics
### - Partial dependence plots
```{r}
# yhat ist die response variable (k-index, simpson oder shannon)
pdp_plot_v_k <- partial(rf_model_v_k, pred.var = "velocity", ice = TRUE, center = TRUE, plot = TRUE, alpha = 0.1, plot.engine = "ggplot2", train = training_v_k, type = "regression")

?partial

# yhat ist die response variable (k-index, simpson oder shannon)
pdp_plot_wd_k <- partial(rf_model_wd_k, pred.var = c("velocity", "wd_cm"), center = TRUE, plot = TRUE, rug = TRUE, alpha = 0.1, plot.engine = "ggplot2", train = training_wd_k, type = "regression")

# Plot the PDP
ggplot(pdp_plot_v_k, aes(velocity, yhat)) + 
  # yhat ist die response variable (k-index, simpson oder shannon)
  geom_line()

# Create the partial dependence plot
pdp_plot_wd_k <- partial(rf_model_wd_k, pred.var = "wd_cm")
pdp_plot_wd_v_k <- partial(rf_model_wd_k, pred.var = "velocity")

pdp_wd <- full_join(pdp_plot_wd_k, pdp_plot_wd_v_k, by = "yhat")

# Plot the PDP
ggplot(pdp_wd, aes(wd_cm, yhat)) + 
  # yhat ist die response variable (k-index, simpson oder shannon)
  facet_wrap(~yhat) 

ggplot(pdp_plot_wd_v_k, aes(velocity, yhat)) + 
  # yhat ist die response variable (k-index, simpson oder shannon)
  geom_line() 
```


### Obs and Pred
#### From Autotuner 
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
rf_predictions_v_k <- predict(autotuner_rf_v_k, newdata = test_v_k)

# shannon index and velocity
rf_predictions_v_s <- predict(autotuner_rf_v_s, newdata = test_v_s)

# abundance and velocity
rf_predictions_v_a <- predict(autotuner_rf_v_a, newdata = test_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
rf_predictions_wd_k <- predict(autotuner_rf_wd_k, newdata = test_wd_k)

# shannon index and velocity + wd
rf_predictions_wd_s <- predict(autotuner_rf_wd_s, newdata = test_wd_s)

# abundance and velocity + wd
rf_predictions_wd_a <- predict(autotuner_rf_wd_a, newdata = test_wd_a)
```

#### From Model 
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
rf_predictions_v_k <- predict(rf_model_v_k, data = test_v_k)$predictions

# shannon index and velocity
rf_predictions_v_s <- predict(rf_model_v_s, data = test_v_s)$predictions

# abundance and velocity
rf_predictions_v_a <- predict(rf_model_v_a, data = test_v_a)$predictions

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
rf_predictions_wd_k <- predict(rf_model_wd_k, data = test_wd_k)$predictions

# shannon index and velocity + wd
rf_predictions_wd_s <- predict(rf_model_wd_s, data = test_wd_s)$predictions

# abundance and velocity + wd
rf_predictions_wd_a <- predict(rf_model_wd_a, data = test_wd_a)$predictions
```

```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
responses_v_k <- test_v_k$k_index

# shannon index and velocity
responses_v_s <- test_v_s$shannon

# abundance and velocity
responses_v_a <- test_v_a$abundance

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
responses_wd_k <- test_wd_k$k_index

# shannon index and velocity + wd
responses_wd_s <- test_wd_s$shannon

# abundance and velocity + wd
responses_wd_a <- test_wd_a$abundance
```


### Deviance explained (R2)
https://de.wikipedia.org/wiki/Bestimmtheitsmaß

Regressionsproblem, wenn Index/kont. Daten vorausgesagt werden
mit variante 1 rechnen 
```{r}
# Calculate R-squared
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity 
r2_v_k <- R2(pred = rf_predictions_v_k, obs = responses_v_k)

# shannon index and velocity 
r2_v_s <- R2(pred = rf_predictions_v_s, obs = responses_v_s)

# abundance and velocity 
r2_v_a <- R2(pred = rf_predictions_v_a, obs = responses_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
r2_wd_k <- R2(pred = rf_predictions_wd_k, obs = responses_wd_k)

# shannon index and velocity + wd 
r2_wd_s <- R2(pred = rf_predictions_wd_s, obs = responses_wd_s)

# abundance and velocity + wd 
r2_wd_a <- R2(pred = rf_predictions_wd_a, obs = responses_wd_a)
```

### RMSE & MAE
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
rmse_v_k <- rmse(actual = responses_v_k, predicted = rf_predictions_v_k)
mae_v_k <- mae(actual = responses_v_k, predicted = rf_predictions_v_k)

# shannon index and velocity
rmse_v_s <- rmse(actual = responses_v_s, predicted = rf_predictions_v_s)
mae_v_s <- mae(actual = responses_v_s, predicted = rf_predictions_v_s)

# abundance and velocity
rmse_v_a <- rmse(actual = responses_v_a, predicted = rf_predictions_v_a)
mae_v_a <- mae(actual = responses_v_a, predicted = rf_predictions_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
rmse_wd_k <- rmse(actual = responses_wd_k, predicted = rf_predictions_wd_k)
mae_wd_k <- mae(actual = responses_wd_k, predicted = rf_predictions_wd_k)

# shannon index and velocity + wd
rmse_wd_s <- rmse(actual = responses_wd_s, predicted = rf_predictions_wd_s)
mae_wd_s <- mae(actual = responses_wd_s, predicted = rf_predictions_wd_s)

# abundance and velocity + wd
rmse_wd_a <- rmse(actual = responses_wd_a, predicted = rf_predictions_wd_a)
mae_wd_a <- mae(actual = responses_wd_a, predicted = rf_predictions_wd_a)
```

### Bias 
keine Metric per se, Abweichung per Mittelwert (wird nicht als performance metric verwendet direkt), hat Bezug zu RMSE
```{r}
# Calculate the differences between predicted and actual values
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
differences_v_k <- rf_predictions_v_k - responses_v_k

# shannon index and velocity
differences_v_s <- rf_predictions_v_s - responses_v_s

# abundance and velocity
differences_v_a <- rf_predictions_v_a - responses_v_a

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
differences_wd_k <- rf_predictions_wd_k - responses_wd_k

# shannon index and velocity + wd
differences_wd_s <- rf_predictions_wd_s - responses_wd_s

# abundance and velocity + wd
differences_wd_a <- rf_predictions_wd_a - responses_wd_a
```


```{r}
# Calculate the mean of the differences (bias)
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
bias_v_k <- mean(differences_v_k)

# shannon index and velocity
bias_v_s <- mean(differences_v_s)

# abundance and velocity
bias_v_a <- mean(differences_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
bias_wd_k <- mean(differences_wd_k)

# shannon index and velocity + wd
bias_wd_s <- mean(differences_wd_s)

# abundance and velocity + wd
bias_wd_a <- mean(differences_wd_a)
```

### Nash-Sutcliffe efficiency (NSE) 
https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffe_model_efficiency_coefficient
spezifisch für hydrologische Modelle 

Range: −∞ to 1
Meaning: NSE = 1 corresponds to a perfect match and values > 0.5 indicate good model performance

```{r}
# Calculate the NSE
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
nse_v_k <- 1 - sum((responses_v_k - rf_predictions_v_k)^2) / sum((responses_v_k - mean(responses_v_k))^2)

# shannon index and velocity
nse_v_s <- 1 - sum((responses_v_s - rf_predictions_v_s)^2) / sum((responses_v_s - mean(responses_v_s))^2)

# abundance and velocity
nse_v_a <- 1 - sum((responses_v_a - rf_predictions_v_a)^2) / sum((responses_v_a - mean(responses_v_a))^2)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
nse_wd_k <- 1 - sum((responses_wd_k - rf_predictions_wd_k)^2) / sum((responses_wd_k - mean(responses_wd_k))^2)

# shannon index and velocity + wd
nse_wd_s <- 1 - sum((responses_wd_s - rf_predictions_wd_s)^2) / sum((responses_wd_s - mean(responses_wd_s))^2)

# abundance and velocity + wd
nse_wd_a <- 1 - sum((responses_wd_a - rf_predictions_wd_a)^2) / sum((responses_wd_a - mean(responses_wd_a))^2)
```

# Boosted Regression Tree
## Hyperparameter tuning
### Create Task & Learner
```{r}
# VELOCITY AS PREDICTOR
# for k_index and velocity 
task_xbrt_v_k <- mlr3spatiotempcv::as_task_regr_st(data_v_k_sp,
  id = "velocity", target = "k_index")

# for shannon index and velocity 
task_xbrt_v_s <- mlr3spatiotempcv::as_task_regr_st(data_v_s_sp,
  id = "velocity", target = "shannon")

# for abundance and velocity 
task_xbrt_v_a <- mlr3spatiotempcv::as_task_regr_st(data_v_a_sp,
  id = "velocity", target = "abundance")

# VELOCITY + WD AS PREDICTORS
# for k_index and velocity + wd
task_xbrt_wd_k <- mlr3spatiotempcv::as_task_regr_st(data_wd_k_sp,
  id = "water_depth", target = "k_index")

# for shannon index and velocity + wd
task_xbrt_wd_s <- mlr3spatiotempcv::as_task_regr_st(data_wd_s_sp,
  id = "water_depth", target = "shannon")

# for abundance and velocity + wd
task_xbrt_wd_a <- mlr3spatiotempcv::as_task_regr_st(data_wd_a_sp,
  id = "water_depth", target = "abundance")

# learner for random forest valid for all models
lrn_xbrt <- lrn("regr.xgboost", predict_type = "response")

# performance estimation level
# perf_level <- mlr3::rsmp("repeated_spcv_coords", folds = 5, repeats = 100)
```

### Specify search space
folgende Parameter sollten getuned werden: 
- bag fraction (search space = 0.5 - 0.75)
- learning rate (search space = ?)
- tree complexity (search space = ?)
```{r}
# specifying the search space
search_space_xbrt <- paradox::ps(
  eta = p_dbl(lower = 0.01, upper = 1.0), # learning rate
  nrounds = p_int(lower = 100, upper = 1000),
  max_depth = p_int(lower = 3, upper = 10), # tree complexity
  subsample = p_dbl(lower = 0.5, upper = 0.75) # bag fraction 
)
```

### Hyperparameter tuning 
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
autotuner_xbrt_v_k <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# shannon index and velocity
autotuner_xbrt_v_s <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# abundance and velocity
autotuner_xbrt_v_a <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
autotuner_xbrt_wd_k <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# shannon index and velocity + wd
autotuner_xbrt_wd_s <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)

# abundance and velocity + wd
autotuner_xbrt_wd_a <- mlr3tuning::AutoTuner$new(
  learner = lrn_xbrt,
  resampling = mlr3::rsmp("spcv_coords", folds = 5), # spatial partitioning
  measure = mlr3::msr("regr.rmse"), # performance measure
  terminator = mlr3tuning::trm("evals", n_evals = 50), # specify 50 iterations / run 50 models
  search_space = search_space_xbrt, # predefined hyperparameter search space
  tuner = mlr3tuning::tnr("random_search") # specify random search
)
```

```{r}
# hyperparameter tuning
set.seed(0412022)

### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
autotuner_xbrt_v_k$train(task_xbrt_v_k)

# shannon index and velocity
autotuner_xbrt_v_s$train(task_xbrt_v_s)

# abundance and velocity
autotuner_xbrt_v_a$train(task_xbrt_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
autotuner_xbrt_wd_k$train(task_xbrt_wd_k)

# shannon index and velocity + wd
autotuner_xbrt_wd_s$train(task_xbrt_wd_s)

# abundance and velocity + wd
autotuner_xbrt_wd_a$train(task_xbrt_wd_a)
```


```{r}
# read the results 
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
autotuner_xbrt_v_k$tuning_result

# shannon index and velocity
autotuner_xbrt_v_s$tuning_result

# abundance and velocity
autotuner_xbrt_v_a$tuning_result

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
autotuner_xbrt_wd_k$tuning_result

# shannon index and velocity + wd
autotuner_xbrt_wd_s$tuning_result

# abundance and velocity + wd
autotuner_xbrt_wd_a$tuning_result
```


## BRT Model
### Prep Data 
```{r}
# make training data
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity 
trainx_v_k <- model.matrix(k_index ~ ., data = training_v_k)

# shannon index and velocity 
trainx_v_s <- model.matrix(shannon ~ ., data = training_v_s)

# abundance and velocity 
trainx_v_a <- model.matrix(abundance ~ ., data = training_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
trainx_wd_k <- model.matrix(k_index ~ ., data = training_wd_k)

# shannon index and velocity + wd
trainx_wd_s <- model.matrix(shannon ~ ., data = training_wd_s)

# abundance and velocity + wd
trainx_wd_a <- model.matrix(abundance ~ ., data = training_wd_a)
```


```{r}
# make testing dataset
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
testx_v_k <- model.matrix(k_index ~ ., data = test_v_k)

# shannon index and velocity
testx_v_s <- model.matrix(shannon ~ ., data = test_v_s)

# abundance and velocity
testx_v_a <- model.matrix(abundance ~ ., data = test_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
testx_wd_k <- model.matrix(k_index ~ ., data = test_wd_k)

# shannon index and velocity + wd
testx_wd_s <- model.matrix(shannon ~ ., data = test_wd_s)

# abundance and velocity + wd
testx_wd_a <- model.matrix(abundance ~ ., data = test_wd_a)
```

### Make models 
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.01838576     922         3 0.6312782          <list[7]> <list[4]>  0.159874
model.xgb_v_k <- xgboost(data = data.matrix(trainx_v_k[ ,-1]),
                     label = as.numeric(as.character(training_v_k$k_index)),
                     eta = 0.01838576,
                     max_depth = 3,
                     nrounds = 922,
                     subsample = 0.6312782,
                     objective = "reg:linear")

# shannon index and velocity
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.06108969     117         4 0.6531705          <list[7]> <list[4]> 0.6777164
model.xgb_v_s <- xgboost(data = data.matrix(trainx_v_s[ ,-1]),
                     label = as.numeric(as.character(training_v_s$shannon)),
                     eta = 0.06108969,
                     max_depth = 4,
                     nrounds = 117,
                     subsample = 0.6531705,
                     objective = "reg:linear")

# abundance and velocity
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.06943808     314         4 0.7209312          <list[7]> <list[4]>  837.6009
model.xgb_v_a <- xgboost(data = data.matrix(trainx_v_a[ ,-1]),
                     label = as.numeric(as.character(training_v_a$abundance)),
                     eta = 0.06943808,
                     max_depth = 4,
                     nrounds = 314,
                     subsample = 0.7209312,
                     objective = "reg:linear")

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.01598317     563         5 0.6270098          <list[7]> <list[4]>  0.160993
model.xgb_wd_k <- xgboost(data = data.matrix(trainx_wd_k[ ,-1]),
                     label = as.numeric(as.character(training_wd_k$k_index)),
                     eta = 0.01598317,
                     max_depth = 5,
                     nrounds = 563,
                     subsample = 0.6270098,
                     objective = "reg:linear")

# shannon index and velocity + wd
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.04028586     240        10 0.5747886          <list[7]> <list[4]> 0.7265847
model.xgb_wd_s <- xgboost(data = data.matrix(trainx_wd_s[ ,-1]),
                     label = as.numeric(as.character(training_wd_s$shannon)),
                     eta = 0.04028586,
                     max_depth = 10,
                     nrounds = 240,
                     subsample = 0.5747886,
                     objective = "reg:linear")

# abundance and velocity + wd
#          eta nrounds max_depth subsample learner_param_vals  x_domain regr.rmse
#1: 0.1906722     586         7 0.7487879          <list[7]> <list[4]>  907.4666
model.xgb_wd_a <- xgboost(data = data.matrix(trainx_wd_a[ ,-1]),
                     label = as.numeric(as.character(training_wd_a$abundance)),
                     eta = 0.1906722,
                     max_depth = 7,
                     nrounds = 586,
                     subsample = 0.7487879,
                     objective = "reg:linear")

```

## Evaluation Metrics
### - Partial dependence plots
https://stackoverflow.com/questions/66016542/partial-dependence-ale-ice-plots-xgboost-in-r
```{r}
 xv <- data.matrix(subset(training_v_k, select = -k_index))  # training features
# Create the partial dependence plot
pdp_plot_v_k <- partial(model.xgb, pred.var = "velocity", ice = TRUE, center = TRUE, plot = TRUE, rug = TRUE, alpha = 0.1, plot.engine = "ggplot2", train = xv, type = "regression")
# p1xv <- partial(xgbc, pred.var = "za1", ice = TRUE, center = TRUE, plot = TRUE, rug = TRUE, alpha = 0.1, plot.engine = "ggplot2", train = xv, type = "regression")

# Plot the PDP
ggplot(pdp_plot_v_k, aes(velocity, yhat)) + 
  # yhat ist die response variable (k-index, simpson oder shannon)
  geom_line()
```

### Obs and Pred 
#### From Autotuner
```{r}
# Get predictions from the XGBoost model
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity 
xbrt_predictions_v_k <- predict(autotuner_xbrt_v_k, newdata = test_v_k)

# shannon index and velocity 
xbrt_predictions_v_s <- predict(autotuner_xbrt_v_s, newdata = test_v_s)

# abundance and velocity 
xbrt_predictions_v_a <- predict(autotuner_xbrt_v_a, newdata = test_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
xbrt_predictions_wd_k <- predict(autotuner_xbrt_wd_k, newdata = test_wd_k)

# shannon index and velocity + wd
xbrt_predictions_wd_s <- predict(autotuner_xbrt_wd_s, newdata = test_wd_s)

# abundance and velocity + wd
xbrt_predictions_wd_a <- predict(autotuner_xbrt_wd_a, newdata = test_wd_a)
```

#### From Model
```{r}
# Get predictions from the XGBoost model
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity 
xbrt_predictions_v_k <- predict(model.xgb_v_k, newdata = data.matrix(testx_v_k[, -1]))

# shannon index and velocity 
xbrt_predictions_v_s <- predict(model.xgb_v_s, newdata = data.matrix(testx_v_s[, -1]))

# abundance and velocity 
xbrt_predictions_v_a <- predict(model.xgb_v_a, newdata = data.matrix(testx_v_a[, -1]))

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
xbrt_predictions_wd_k <- predict(model.xgb_wd_k, newdata = data.matrix(testx_wd_k[, -1]))

# shannon index and velocity + wd
xbrt_predictions_wd_s <- predict(model.xgb_wd_s, newdata = data.matrix(testx_wd_s[, -1]))

# abundance and velocity + wd
xbrt_predictions_wd_a <- predict(model.xgb_wd_a, newdata = data.matrix(testx_wd_a[, -1]))
```

### Deviance explained (R2)
```{r}
# Calculate R-squared
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity 
brt_r2_v_k <- R2(pred = xbrt_predictions_v_k, obs = responses_v_k)

# shannon index and velocity 
brt_r2_v_s <- R2(pred = xbrt_predictions_v_s, obs = responses_v_s)

# abundance and velocity 
brt_r2_v_a <- R2(pred = xbrt_predictions_v_a, obs = responses_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
brt_r2_wd_k <- R2(pred = xbrt_predictions_wd_k, obs = responses_wd_k)

# shannon index and velocity + wd 
brt_r2_wd_s <- R2(pred = xbrt_predictions_wd_s, obs = responses_wd_s)

# abundance and velocity + wd 
brt_r2_wd_a <- R2(pred = xbrt_predictions_wd_a, obs = responses_wd_a)
```

### RMSE & MAE
```{r}
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
brt_rmse_v_k <- rmse(actual = responses_v_k, predicted = xbrt_predictions_v_k)
brt_mae_v_k <- mae(actual = responses_v_k, predicted = xbrt_predictions_v_k)

# shannon index and velocity
brt_rmse_v_s <- rmse(actual = responses_v_s, predicted = xbrt_predictions_v_s)
brt_mae_v_s <- mae(actual = responses_v_s, predicted = xbrt_predictions_v_s)

# abundance and velocity
brt_rmse_v_a <- rmse(actual = responses_v_a, predicted = xbrt_predictions_v_a)
brt_mae_v_a <- mae(actual = responses_v_a, predicted = xbrt_predictions_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
brt_rmse_wd_k <- rmse(actual = responses_wd_k, predicted = xbrt_predictions_wd_k)
brt_mae_wd_k <- mae(actual = responses_wd_k, predicted = xbrt_predictions_wd_k)

# shannon index and velocity + wd
brt_rmse_wd_s <- rmse(actual = responses_wd_s, predicted = xbrt_predictions_wd_s)
brt_mae_wd_s <- mae(actual = responses_wd_s, predicted = xbrt_predictions_wd_s)

# abundance and velocity + wd
brt_rmse_wd_a <- rmse(actual = responses_wd_a, predicted = xbrt_predictions_wd_a)
brt_mae_wd_a <- mae(actual = responses_wd_a, predicted = xbrt_predictions_wd_a)
```

### Bias
```{r}
# Calculate the differences between predicted and actual values
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
brt_differences_v_k <- xbrt_predictions_v_k - responses_v_k

# shannon index and velocity
brt_differences_v_s <- xbrt_predictions_v_s - responses_v_s

# abundance and velocity
brt_differences_v_a <- xbrt_predictions_v_a - responses_v_a

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
brt_differences_wd_k <- xbrt_predictions_wd_k - responses_wd_k

# shannon index and velocity + wd
brt_differences_wd_s <- xbrt_predictions_wd_s - responses_wd_s

# abundance and velocity + wd
brt_differences_wd_a <- xbrt_predictions_wd_a - responses_wd_a
```


```{r}
# Calculate the mean of the differences (bias)
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
brt_bias_v_k <- mean(brt_differences_v_k)

# shannon index and velocity
brt_bias_v_s <- mean(brt_differences_v_s)

# abundance and velocity
brt_bias_v_a <- mean(brt_differences_v_a)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
brt_bias_wd_k <- mean(brt_differences_wd_k)

# shannon index and velocity + wd
brt_bias_wd_s <- mean(brt_differences_wd_s)

# abundance and velocity + wd
brt_bias_wd_a <- mean(brt_differences_wd_a)
```

### Nash-Sutcliffe efficiency (NSE) 
spezifisch für hydrologische Modelle 
```{r}
# Calculate the NSE
### ONLY VELOCITY AS PREDICTOR ###
# k_index and velocity
brt_nse_v_k <- 1 - sum((responses_v_k - xbrt_predictions_v_k)^2) / sum((responses_v_k - mean(responses_v_k))^2)

# shannon index and velocity
brt_nse_v_s <- 1 - sum((responses_v_s - xbrt_predictions_v_s)^2) / sum((responses_v_s - mean(responses_v_s))^2)

# abundance and velocity
brt_nse_v_a <- 1 - sum((responses_v_a - xbrt_predictions_v_a)^2) / sum((responses_v_a - mean(responses_v_a))^2)

### VELOCITY + WD AS PREDICTORS ###
# k_index and velocity + wd
brt_nse_wd_k <- 1 - sum((responses_wd_k - xbrt_predictions_wd_k)^2) / sum((responses_wd_k - mean(responses_wd_k))^2)

# shannon index and velocity + wd
brt_nse_wd_s <- 1 - sum((responses_wd_s - xbrt_predictions_wd_s)^2) / sum((responses_wd_s - mean(responses_wd_s))^2)

# abundance and velocity + wd
brt_nse_wd_a <- 1 - sum((responses_wd_a - xbrt_predictions_wd_a)^2) / sum((responses_wd_a - mean(responses_wd_a))^2)
```

## Write Evaluation Results 
```{r}
# write evaluation metrics into df
results <- data.frame(r2 = c(r2_v_k, r2_v_s, r2_v_a, r2_wd_k, r2_wd_s,
                             r2_wd_a, brt_r2_v_k, brt_r2_v_s, brt_r2_v_a, brt_r2_wd_k, brt_r2_wd_s, brt_r2_wd_a),
                      nse = c(nse_v_k, nse_v_s, nse_v_a, nse_wd_k, nse_wd_s,
                              nse_wd_a, brt_nse_v_k, brt_nse_v_s, brt_nse_v_a, brt_nse_wd_k, brt_nse_wd_s, brt_nse_wd_a),
                        bias = c(bias_v_k, bias_v_s, bias_v_a, bias_wd_k,
                               bias_wd_s, bias_wd_a, brt_bias_v_k, brt_bias_v_s, brt_bias_v_a, brt_bias_wd_k, brt_bias_wd_s, brt_bias_wd_a),
                        rmse = c(rmse_v_k, rmse_v_s, rmse_v_a, rmse_wd_k,
                                  rmse_wd_s, rmse_wd_a, brt_rmse_v_k, brt_rmse_v_s, brt_rmse_v_a, brt_rmse_wd_k, brt_rmse_wd_s, brt_rmse_wd_a), 
                         mae = c(mae_v_k, mae_v_s, mae_v_a, mae_wd_k,
                                 mae_wd_s,mae_wd_a, brt_mae_v_k, brt_mae_v_s, brt_mae_v_a, brt_mae_wd_k, brt_mae_wd_s, brt_mae_wd_a),
                         predictor = c("velocity", "velocity", "velocity",
                                       "velocity + wd", "velocity + wd",
                                       "velocity + wd", "velocity", "velocity", "velocity",
                                       "velocity + wd", "velocity + wd",
                                       "velocity + wd"),
                         index = c("k-index", "shannon index", "abundance",
                                   "k-index", "shannon index", "abundance", "k-index", "shannon index", "abundance",
                                   "k-index", "shannon index", "abundance"),
                      model = c("rf", "rf", "rf", "rf", "rf", "rf", "xgbrt", "xgbrt", "xgbrt", "xgbrt", "xgbrt", "xgbrt"))
```
 
## Extract 
### Predict to maps ML models - here RF
Ersetze Raster durch Raster vom MZB Sampling Tag 
```{r}
# read rasters containing wd and velocity 
GL1_samp <- stack("Pre_Processing/rasters_stacked/GL1_3_28.grd")
GL2_samp <- stack("Pre_Processing/rasters_stacked/GL2_3_21.grd")
L2_samp <- stack("Pre_Processing/rasters_stacked/L2_2_40.grd")
M1_samp <- stack("Pre_Processing/rasters_stacked/M1_0_47.grd")
S1_samp <- stack("Pre_Processing/rasters_stacked/S1_2_00.grd")
S2_samp <- stack("Pre_Processing/rasters_stacked/S2_2_00.grd")
TH4_samp <- stack("Pre_Processing/rasters_stacked/TH4_11_45.grd")
VR3_samp <- stack("Pre_Processing/rasters_stacked/VR3_2_90.grd")

# rename raster 
names(GL1_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(GL2_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(L2_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(M1_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(S1_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(S2_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(TH4_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names
names(VR3_samp) <- c("velocity", "wd_cm")  # Replace with your desired new names

# assign coordinate system 
crs(GL1_samp) <- "EPSG: 2056"
crs(GL2_samp) <- "EPSG: 2056"
crs(L2_samp) <- "EPSG: 2056"
crs(M1_samp) <- "EPSG: 2056"
crs(S1_samp) <- "EPSG: 2056"
crs(S2_samp) <- "EPSG: 2056"
crs(TH4_samp) <- "EPSG: 2056"
crs(VR3_samp) <- "EPSG: 2056"
```

### Predict Models to Maps 
```{r}
# predict ML model to rasters with velocity and wd 
### RANDOM FORESTS ###
# GL1 - all indices with velocity and wd as predictors
GL1_pred_rf_wd_k <- terra::predict(GL1_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
GL1_pred_rf_wd_s <- terra::predict(GL1_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
GL1_pred_rf_wd_a <- terra::predict(GL1_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# GL1 - all indices with only velocity as predictor
GL1_pred_rf_v_k <- terra::predict(GL1_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
GL1_pred_rf_v_s <- terra::predict(GL1_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
GL1_pred_rf_v_a <- terra::predict(GL1_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# GL2 - all indices with velocity and wd as predictors 
GL2_pred_rf_wd_k <- terra::predict(GL2_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
GL2_pred_rf_wd_s <- terra::predict(GL2_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
GL2_pred_rf_wd_a <- terra::predict(GL2_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# GL2 - all indices with only velocity predictor
GL2_pred_rf_v_k <- terra::predict(GL2_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
GL2_pred_rf_v_s <- terra::predict(GL2_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
GL2_pred_rf_v_a <- terra::predict(GL2_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# L2 - all indices with velocity and wd as predictors 
L2_pred_rf_wd_k <- terra::predict(L2_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
L2_pred_rf_wd_s <- terra::predict(L2_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
L2_pred_rf_wd_a <- terra::predict(L2_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# L2 - all indices with only velocity as predictor
L2_pred_rf_v_k <- terra::predict(L2_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
L2_pred_rf_v_s <- terra::predict(L2_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
L2_pred_rf_v_a <- terra::predict(L2_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# M1  - all indices with velocity and wd as predictors 
M1_pred_rf_wd_k <- terra::predict(M1_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
M1_pred_rf_wd_s <- terra::predict(M1_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
M1_pred_rf_wd_a <- terra::predict(M1_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# M1  - all indices with only velocity as predictor
M1_pred_rf_v_k <- terra::predict(M1_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
M1_pred_rf_v_s <- terra::predict(M1_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
M1_pred_rf_v_a <- terra::predict(M1_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# S1  - all indices with velocity and wd as predictors 
S1_pred_rf_wd_k <- terra::predict(S1_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
S1_pred_rf_wd_s <- terra::predict(S1_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
S1_pred_rf_wd_a <- terra::predict(S1_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# S1  - all indices with only velocity as predictor
S1_pred_rf_v_k <- terra::predict(S1_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
S1_pred_rf_v_s <- terra::predict(S1_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
S1_pred_rf_v_a <- terra::predict(S1_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# S2  - all indices with velocity and wd as predictors 
S2_pred_rf_wd_k <- terra::predict(S2_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
S2_pred_rf_wd_s <- terra::predict(S2_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
S2_pred_rf_wd_a <- terra::predict(S2_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# S2  - all indices with only velocity as predictor
S2_pred_rf_v_k <- terra::predict(S2_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
S2_pred_rf_v_s <- terra::predict(S2_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
S2_pred_rf_v_a <- terra::predict(S2_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# TH4  - all indices with velocity and wd as predictors 
TH4_pred_rf_wd_k <- terra::predict(TH4_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
TH4_pred_rf_wd_s <- terra::predict(TH4_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
TH4_pred_rf_wd_a <- terra::predict(TH4_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# TH4  - all indices with only velocity as predictor
TH4_pred_rf_v_k <- terra::predict(TH4_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
TH4_pred_rf_v_s <- terra::predict(TH4_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
TH4_pred_rf_v_a <- terra::predict(TH4_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")

# VR3  - all indices with velocity and wd as predictors 
VR3_pred_rf_wd_k <- terra::predict(VR3_samp, model = autotuner_rf_wd_k, fun = predict, index = 2)
VR3_pred_rf_wd_s <- terra::predict(VR3_samp, model = autotuner_rf_wd_s, fun = predict, index = 2)
VR3_pred_rf_wd_a <- terra::predict(VR3_samp, model = autotuner_rf_wd_a, fun = predict, index = 2)

# VR3  - all indices with only velocity as predictor
VR3_pred_rf_v_k <- terra::predict(VR3_samp, model = autotuner_rf_v_k, fun = predict, index = "velocity")
VR3_pred_rf_v_s <- terra::predict(VR3_samp, model = autotuner_rf_v_s, fun = predict, index = "velocity")
VR3_pred_rf_v_a <- terra::predict(VR3_samp, model = autotuner_rf_v_a, fun = predict, index = "velocity")
```


```{r}
### BOOSTED REGRESSION TREE ###
# GL1 - all indices with velocity and wd as predictors
GL1_pred_brt_wd_k <- terra::predict(GL1_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
GL1_pred_brt_wd_s <- terra::predict(GL1_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
GL1_pred_brt_wd_a <- terra::predict(GL1_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# GL1 - all indices with only velocity as predictor
GL1_pred_brt_v_k <- terra::predict(GL1_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
GL1_pred_brt_v_s <- terra::predict(GL1_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
GL1_pred_brt_v_a <- terra::predict(GL1_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# GL2 - all indices with velocity and wd as predictors
GL2_pred_brt_wd_k <- terra::predict(GL2_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
GL2_pred_brt_wd_s <- terra::predict(GL2_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
GL2_pred_brt_wd_a <- terra::predict(GL2_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# GL2 - all indices with only velocity as predictor
GL2_pred_brt_v_k <- terra::predict(GL2_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
GL2_pred_brt_v_s <- terra::predict(GL2_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
GL2_pred_brt_v_a <- terra::predict(GL2_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# L2 - all indices with velocity and wd as predictors
L2_pred_brt_wd_k <- terra::predict(L2_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
L2_pred_brt_wd_s <- terra::predict(L2_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
L2_pred_brt_wd_a <- terra::predict(L2_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# L2 - all indices with only velocity as predictor
L2_pred_brt_v_k <- terra::predict(L2_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
L2_pred_brt_v_s <- terra::predict(L2_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
L2_pred_brt_v_a <- terra::predict(L2_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# M1 - all indices with velocity and wd as predictors
M1_pred_brt_wd_k <- terra::predict(M1_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
M1_pred_brt_wd_s <- terra::predict(M1_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
M1_pred_brt_wd_a <- terra::predict(M1_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# M1 - all indices with only velocity as predictor
M1_pred_brt_v_k <- terra::predict(M1_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
M1_pred_brt_v_s <- terra::predict(M1_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
M1_pred_brt_v_a <- terra::predict(M1_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# S1 - all indices with velocity and wd as predictors
S1_pred_brt_wd_k <- terra::predict(S1_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
S1_pred_brt_wd_s <- terra::predict(S1_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
S1_pred_brt_wd_a <- terra::predict(S1_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# S1 - all indices with only velocity as predictor
S1_pred_brt_v_k <- terra::predict(S1_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
S1_pred_brt_v_s <- terra::predict(S1_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
S1_pred_brt_v_a <- terra::predict(S1_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# S2 - all indices with velocity and wd as predictors
S2_pred_brt_wd_k <- terra::predict(S2_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
S2_pred_brt_wd_s <- terra::predict(S2_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
S2_pred_brt_wd_a <- terra::predict(S2_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# S2 - all indices with only velocity as predictor
S2_pred_brt_v_k <- terra::predict(S2_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
S2_pred_brt_v_s <- terra::predict(S2_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
S2_pred_brt_v_a <- terra::predict(S2_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# TH4 - all indices with velocity and wd as predictors
TH4_pred_brt_wd_k <- terra::predict(TH4_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
TH4_pred_brt_wd_s <- terra::predict(TH4_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
TH4_pred_brt_wd_a <- terra::predict(TH4_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# TH4 - all indices with only velocity as predictor
TH4_pred_brt_v_k <- terra::predict(TH4_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
TH4_pred_brt_v_s <- terra::predict(TH4_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
TH4_pred_brt_v_a <- terra::predict(TH4_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")

# VR3 - all indices with velocity and wd as predictors
VR3_pred_brt_wd_k <- terra::predict(VR3_samp, model = autotuner_xbrt_wd_k, fun = predict, index = 2)
VR3_pred_brt_wd_s <- terra::predict(VR3_samp, model = autotuner_xbrt_wd_s, fun = predict, index = 2)
VR3_pred_brt_wd_a <- terra::predict(VR3_samp, model = autotuner_xbrt_wd_a, fun = predict, index = 2)

# VR3 - all indices with only velocity and as predictor
VR3_pred_brt_v_k <- terra::predict(VR3_samp, model = autotuner_xbrt_v_k, fun = predict, index = "velocity")
VR3_pred_brt_v_s <- terra::predict(VR3_samp, model = autotuner_xbrt_v_s, fun = predict, index = "velocity")
VR3_pred_brt_v_a <- terra::predict(VR3_samp, model = autotuner_xbrt_v_a, fun = predict, index = "velocity")
```

```{r}
# read all raster results (one time flow velocity classes and one time for habitat suitability)
# prep extraction data 
## GL1
coord_GL1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "GL1") |>
  dplyr::select(x, y) 

GL1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "GL1")

## GL2
coord_GL2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "GL2") |>
  dplyr::select(x, y) 

GL2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "GL2")

## L2
coord_L2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "L2") |>
  dplyr::select(x, y) 

L2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "L2")

## M1
coord_M1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "M1") |>
  dplyr::select(x, y) 

M1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "M1")

## S1
coord_S1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "S1") |>
  dplyr::select(x, y) 

S1 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "S1")

## S2
coord_S2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "S2") |>
  dplyr::select(x, y) 

S2 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "S2")

## TH4
coord_TH4 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "TH4") |>
  dplyr::select(x, y) 

TH4 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "TH4")

## VR3
coord_VR3 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "VR3") |>
  dplyr::select(x, y) 

VR3 <- test_wd |>
  subset(Reach_Untersuchungsstelle == "VR3")
```

### Extract Results
```{r}
# extract raster information for regression analysis later
# GL1 
# random forest 
regr_rf_data_GL1_wd_k <- extract(GL1_pred_rf_wd_k, coord_GL1) 
regr_rf_data_GL1_wd_s <- extract(GL1_pred_rf_wd_s, coord_GL1) 
regr_rf_data_GL1_wd_a <- extract(GL1_pred_rf_wd_a, coord_GL1) 

regr_rf_data_GL1_v_k <- extract(GL1_pred_rf_v_k, coord_GL1) 
regr_rf_data_GL1_v_s <- extract(GL1_pred_rf_v_s, coord_GL1) 
regr_rf_data_GL1_v_a <- extract(GL1_pred_rf_v_a, coord_GL1) 

# boosted regression tree
regr_brt_data_GL1_wd_k <- extract(GL1_pred_brt_wd_k, coord_GL1) 
regr_brt_data_GL1_wd_s <- extract(GL1_pred_brt_wd_s, coord_GL1) 
regr_brt_data_GL1_wd_a <- extract(GL1_pred_brt_wd_a, coord_GL1) 

regr_brt_data_GL1_v_k <- extract(GL1_pred_brt_v_k, coord_GL1) 
regr_brt_data_GL1_v_s <- extract(GL1_pred_brt_v_s, coord_GL1) 
regr_brt_data_GL1_v_a <- extract(GL1_pred_brt_v_a, coord_GL1)

# GL2
# random forest 
regr_rf_data_GL2_wd_k <- extract(GL2_pred_rf_wd_k, coord_GL2) 
regr_rf_data_GL2_wd_s <- extract(GL2_pred_rf_wd_s, coord_GL2) 
regr_rf_data_GL2_wd_a <- extract(GL2_pred_rf_wd_a, coord_GL2) 

regr_rf_data_GL2_v_k <- extract(GL2_pred_rf_v_k, coord_GL2) 
regr_rf_data_GL2_v_s <- extract(GL2_pred_rf_v_s, coord_GL2) 
regr_rf_data_GL2_v_a <- extract(GL2_pred_rf_v_a, coord_GL2)

# boosted regression tree
regr_brt_data_GL2_wd_k <- extract(GL2_pred_brt_wd_k, coord_GL2) 
regr_brt_data_GL2_wd_s <- extract(GL2_pred_brt_wd_s, coord_GL2) 
regr_brt_data_GL2_wd_a <- extract(GL2_pred_brt_wd_a, coord_GL2) 

regr_brt_data_GL2_v_k <- extract(GL2_pred_brt_v_k, coord_GL2) 
regr_brt_data_GL2_v_s <- extract(GL2_pred_brt_v_s, coord_GL2) 
regr_brt_data_GL2_v_a <- extract(GL2_pred_brt_v_a, coord_GL2)

# L2
# random forest 
regr_rf_data_L2_wd_k <- extract(L2_pred_rf_wd_k, coord_L2) 
regr_rf_data_L2_wd_s <- extract(L2_pred_rf_wd_s, coord_L2) 
regr_rf_data_L2_wd_a <- extract(L2_pred_rf_wd_a, coord_L2) 

regr_rf_data_L2_v_k <- extract(L2_pred_rf_v_k, coord_L2) 
regr_rf_data_L2_v_s <- extract(L2_pred_rf_v_s, coord_L2) 
regr_rf_data_L2_v_a <- extract(L2_pred_rf_v_a, coord_L2)

# boosted regression tree
regr_brt_data_L2_wd_k <- extract(L2_pred_brt_wd_k, coord_L2) 
regr_brt_data_L2_wd_s <- extract(L2_pred_brt_wd_s, coord_L2) 
regr_brt_data_L2_wd_a <- extract(L2_pred_brt_wd_a, coord_L2) 

regr_brt_data_L2_v_k <- extract(L2_pred_brt_v_k, coord_L2) 
regr_brt_data_L2_v_s <- extract(L2_pred_brt_v_s, coord_L2) 
regr_brt_data_L2_v_a <- extract(L2_pred_brt_v_a, coord_L2)

# M1
# random forest 
regr_rf_data_M1_wd_k <- extract(M1_pred_rf_wd_k, coord_M1) 
regr_rf_data_M1_wd_s <- extract(M1_pred_rf_wd_s, coord_M1) 
regr_rf_data_M1_wd_a <- extract(M1_pred_rf_wd_a, coord_M1) 

regr_rf_data_M1_v_k <- extract(M1_pred_rf_v_k, coord_M1) 
regr_rf_data_M1_v_s <- extract(M1_pred_rf_v_s, coord_M1) 
regr_rf_data_M1_v_a <- extract(M1_pred_rf_v_a, coord_M1)

# boosted regression tree
regr_brt_data_M1_wd_k <- extract(M1_pred_brt_wd_k, coord_M1) 
regr_brt_data_M1_wd_s <- extract(M1_pred_brt_wd_s, coord_M1) 
regr_brt_data_M1_wd_a <- extract(M1_pred_brt_wd_a, coord_M1) 

regr_brt_data_M1_v_k <- extract(M1_pred_brt_v_k, coord_M1) 
regr_brt_data_M1_v_s <- extract(M1_pred_brt_v_s, coord_M1) 
regr_brt_data_M1_v_a <- extract(M1_pred_brt_v_a, coord_M1)

# S1
# random forest 
regr_rf_data_S1_wd_k <- extract(S1_pred_rf_wd_k, coord_S1) 
regr_rf_data_S1_wd_s <- extract(S1_pred_rf_wd_s, coord_S1) 
regr_rf_data_S1_wd_a <- extract(S1_pred_rf_wd_a, coord_S1) 

regr_rf_data_S1_v_k <- extract(S1_pred_rf_v_k, coord_S1) 
regr_rf_data_S1_v_s <- extract(S1_pred_rf_v_s, coord_S1) 
regr_rf_data_S1_v_a <- extract(S1_pred_rf_v_a, coord_S1)

# boosted regression tree
regr_brt_data_S1_wd_k <- extract(S1_pred_brt_wd_k, coord_S1) 
regr_brt_data_S1_wd_s <- extract(S1_pred_brt_wd_s, coord_S1) 
regr_brt_data_S1_wd_a <- extract(S1_pred_brt_wd_a, coord_S1) 

regr_brt_data_S1_v_k <- extract(S1_pred_brt_v_k, coord_S1) 
regr_brt_data_S1_v_s <- extract(S1_pred_brt_v_s, coord_S1) 
regr_brt_data_S1_v_a <- extract(S1_pred_brt_v_a, coord_S1)

# S2
# random forest 
regr_rf_data_S2_wd_k <- extract(S2_pred_rf_wd_k, coord_S2) 
regr_rf_data_S2_wd_s <- extract(S2_pred_rf_wd_s, coord_S2) 
regr_rf_data_S2_wd_a <- extract(S2_pred_rf_wd_a, coord_S2) 

regr_rf_data_S2_v_k <- extract(S2_pred_rf_v_k, coord_S2) 
regr_rf_data_S2_v_s <- extract(S2_pred_rf_v_s, coord_S2) 
regr_rf_data_S2_v_a <- extract(S2_pred_rf_v_a, coord_S2)

# boosted regression tree
regr_brt_data_S2_wd_k <- extract(S2_pred_brt_wd_k, coord_S2) 
regr_brt_data_S2_wd_s <- extract(S2_pred_brt_wd_s, coord_S2) 
regr_brt_data_S2_wd_a <- extract(S2_pred_brt_wd_a, coord_S2) 

regr_brt_data_S2_v_k <- extract(S2_pred_brt_v_k, coord_S2) 
regr_brt_data_S2_v_s <- extract(S2_pred_brt_v_s, coord_S2) 
regr_brt_data_S2_v_a <- extract(S2_pred_brt_v_a, coord_S2)

# TH4
# random forest 
regr_rf_data_TH4_wd_k <- extract(TH4_pred_rf_wd_k, coord_TH4) 
regr_rf_data_TH4_wd_s <- extract(TH4_pred_rf_wd_s, coord_TH4) 
regr_rf_data_TH4_wd_a <- extract(TH4_pred_rf_wd_a, coord_TH4) 

regr_rf_data_TH4_v_k <- extract(TH4_pred_rf_v_k, coord_TH4) 
regr_rf_data_TH4_v_s <- extract(TH4_pred_rf_v_s, coord_TH4) 
regr_rf_data_TH4_v_a <- extract(TH4_pred_rf_v_a, coord_TH4)

# boosted regression tree
regr_brt_data_TH4_wd_k <- extract(TH4_pred_brt_wd_k, coord_TH4) 
regr_brt_data_TH4_wd_s <- extract(TH4_pred_brt_wd_s, coord_TH4) 
regr_brt_data_TH4_wd_a <- extract(TH4_pred_brt_wd_a, coord_TH4) 

regr_brt_data_TH4_v_k <- extract(TH4_pred_brt_v_k, coord_TH4) 
regr_brt_data_TH4_v_s <- extract(TH4_pred_brt_v_s, coord_TH4) 
regr_brt_data_TH4_v_a <- extract(TH4_pred_brt_v_a, coord_TH4)

# VR3
# random forest 
regr_rf_data_VR3_wd_k <- extract(VR3_pred_rf_wd_k, coord_VR3) 
regr_rf_data_VR3_wd_s <- extract(VR3_pred_rf_wd_s, coord_VR3) 
regr_rf_data_VR3_wd_a <- extract(VR3_pred_rf_wd_a, coord_VR3) 

regr_rf_data_VR3_v_k <- extract(VR3_pred_rf_v_k, coord_VR3) 
regr_rf_data_VR3_v_s <- extract(VR3_pred_rf_v_s, coord_VR3) 
regr_rf_data_VR3_v_a <- extract(VR3_pred_rf_v_a, coord_VR3)

# boosted regression tree
regr_brt_data_VR3_wd_k <- extract(VR3_pred_brt_wd_k, coord_VR3) 
regr_brt_data_VR3_wd_s <- extract(VR3_pred_brt_wd_s, coord_VR3) 
regr_brt_data_VR3_wd_a <- extract(VR3_pred_brt_wd_a, coord_VR3) 

regr_brt_data_VR3_v_k <- extract(VR3_pred_brt_v_k, coord_VR3) 
regr_brt_data_VR3_v_s <- extract(VR3_pred_brt_v_s, coord_VR3) 
regr_brt_data_VR3_v_a <- extract(VR3_pred_brt_v_a, coord_VR3)
```

### Combine into DF
```{r}
# combine all results into dataframe
# GL1
data_GL1 <- cbind(regr_rf_data_GL1_wd_k, regr_rf_data_GL1_wd_s, regr_rf_data_GL1_wd_a, regr_rf_data_GL1_v_k, regr_rf_data_GL1_v_s, regr_rf_data_GL1_v_a, regr_brt_data_GL1_wd_k, regr_brt_data_GL1_wd_s, regr_brt_data_GL1_wd_a, regr_brt_data_GL1_v_k, regr_brt_data_GL1_v_s, regr_brt_data_GL1_v_a, GL1) |>
  rename(rf_pred_k_index_2 = regr_rf_data_GL1_wd_k,
         rf_pred_shannon_2 = regr_rf_data_GL1_wd_s,
         rf_pred_abundance_2 = regr_rf_data_GL1_wd_a,
         rf_pred_k_index_v = regr_rf_data_GL1_v_k,
         rf_pred_shannon_v = regr_rf_data_GL1_v_s,
         rf_pred_abundance_v = regr_rf_data_GL1_v_a,
         brt_pred_k_index_2 = regr_brt_data_GL1_wd_k,
         brt_pred_shannon_2 = regr_brt_data_GL1_wd_s,
         brt_pred_abundance_2 = regr_brt_data_GL1_wd_a,
         brt_pred_k_index_v = regr_brt_data_GL1_v_k,
         brt_pred_shannon_v = regr_brt_data_GL1_v_s,
         brt_pred_abundance_v = regr_brt_data_GL1_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# GL2
data_GL2 <- cbind(regr_rf_data_GL2_wd_k, regr_rf_data_GL2_wd_s, regr_rf_data_GL2_wd_a, regr_rf_data_GL2_v_k, regr_rf_data_GL2_v_s, regr_rf_data_GL2_v_a, regr_brt_data_GL2_wd_k, regr_brt_data_GL2_wd_s, regr_brt_data_GL2_wd_a, regr_brt_data_GL2_v_k, regr_brt_data_GL2_v_s, regr_brt_data_GL2_v_a, GL2) |>
  rename(rf_pred_k_index_2 = regr_rf_data_GL2_wd_k,
         rf_pred_shannon_2 = regr_rf_data_GL2_wd_s,
         rf_pred_abundance_2 = regr_rf_data_GL2_wd_a,
         rf_pred_k_index_v = regr_rf_data_GL2_v_k,
         rf_pred_shannon_v = regr_rf_data_GL2_v_s,
         rf_pred_abundance_v = regr_rf_data_GL2_v_a,
         brt_pred_k_index_2 = regr_brt_data_GL2_wd_k,
         brt_pred_shannon_2 = regr_brt_data_GL2_wd_s,
         brt_pred_abundance_2 = regr_brt_data_GL2_wd_a,
         brt_pred_k_index_v = regr_brt_data_GL2_v_k,
         brt_pred_shannon_v = regr_brt_data_GL2_v_s,
         brt_pred_abundance_v = regr_brt_data_GL2_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# L2
data_L2 <- cbind(regr_rf_data_L2_wd_k, regr_rf_data_L2_wd_s, regr_rf_data_L2_wd_a, regr_rf_data_L2_v_k, regr_rf_data_L2_v_s, regr_rf_data_L2_v_a, regr_brt_data_L2_wd_k, regr_brt_data_L2_wd_s, regr_brt_data_L2_wd_a, regr_brt_data_L2_v_k, regr_brt_data_L2_v_s, regr_brt_data_L2_v_a, L2) |>
  rename(rf_pred_k_index_2 = regr_rf_data_L2_wd_k,
         rf_pred_shannon_2 = regr_rf_data_L2_wd_s,
         rf_pred_abundance_2 = regr_rf_data_L2_wd_a,
         rf_pred_k_index_v = regr_rf_data_L2_v_k,
         rf_pred_shannon_v = regr_rf_data_L2_v_s,
         rf_pred_abundance_v = regr_rf_data_L2_v_a,
         brt_pred_k_index_2 = regr_brt_data_L2_wd_k,
         brt_pred_shannon_2 = regr_brt_data_L2_wd_s,
         brt_pred_abundance_2 = regr_brt_data_L2_wd_a,
         brt_pred_k_index_v = regr_brt_data_L2_v_k,
         brt_pred_shannon_v = regr_brt_data_L2_v_s,
         brt_pred_abundance_v = regr_brt_data_L2_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# M1
data_M1 <- cbind(regr_rf_data_M1_wd_k, regr_rf_data_M1_wd_s, regr_rf_data_M1_wd_a, regr_rf_data_M1_v_k, regr_rf_data_M1_v_s, regr_rf_data_M1_v_a, regr_brt_data_M1_wd_k, regr_brt_data_M1_wd_s, regr_brt_data_M1_wd_a, regr_brt_data_M1_v_k, regr_brt_data_M1_v_s, regr_brt_data_M1_v_a, M1) |>
  rename(rf_pred_k_index_2 = regr_rf_data_M1_wd_k,
         rf_pred_shannon_2 = regr_rf_data_M1_wd_s,
         rf_pred_abundance_2 = regr_rf_data_M1_wd_a,
         rf_pred_k_index_v = regr_rf_data_M1_v_k,
         rf_pred_shannon_v = regr_rf_data_M1_v_s,
         rf_pred_abundance_v = regr_rf_data_M1_v_a,
         brt_pred_k_index_2 = regr_brt_data_M1_wd_k,
         brt_pred_shannon_2 = regr_brt_data_M1_wd_s,
         brt_pred_abundance_2 = regr_brt_data_M1_wd_a,
         brt_pred_k_index_v = regr_brt_data_M1_v_k,
         brt_pred_shannon_v = regr_brt_data_M1_v_s,
         brt_pred_abundance_v = regr_brt_data_M1_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# S1
data_S1 <- cbind(regr_rf_data_S1_wd_k, regr_rf_data_S1_wd_s, regr_rf_data_S1_wd_a, regr_rf_data_S1_v_k, regr_rf_data_S1_v_s, regr_rf_data_S1_v_a, regr_brt_data_S1_wd_k, regr_brt_data_S1_wd_s, regr_brt_data_S1_wd_a, regr_brt_data_S1_v_k, regr_brt_data_S1_v_s, regr_brt_data_S1_v_a, S1) |>
  rename(rf_pred_k_index_2 = regr_rf_data_S1_wd_k,
         rf_pred_shannon_2 = regr_rf_data_S1_wd_s,
         rf_pred_abundance_2 = regr_rf_data_S1_wd_a,
         rf_pred_k_index_v = regr_rf_data_S1_v_k,
         rf_pred_shannon_v = regr_rf_data_S1_v_s,
         rf_pred_abundance_v = regr_rf_data_S1_v_a,
         brt_pred_k_index_2 = regr_brt_data_S1_wd_k,
         brt_pred_shannon_2 = regr_brt_data_S1_wd_s,
         brt_pred_abundance_2 = regr_brt_data_S1_wd_a,
         brt_pred_k_index_v = regr_brt_data_S1_v_k,
         brt_pred_shannon_v = regr_brt_data_S1_v_s,
         brt_pred_abundance_v = regr_brt_data_S1_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# S2
data_S2 <- cbind(regr_rf_data_S2_wd_k, regr_rf_data_S2_wd_s, regr_rf_data_S2_wd_a, regr_rf_data_S2_v_k, regr_rf_data_S2_v_s, regr_rf_data_S2_v_a, regr_brt_data_S2_wd_k, regr_brt_data_S2_wd_s, regr_brt_data_S2_wd_a, regr_brt_data_S2_v_k, regr_brt_data_S2_v_s, regr_brt_data_S2_v_a, S2) |>
  rename(rf_pred_k_index_2 = regr_rf_data_S2_wd_k,
         rf_pred_shannon_2 = regr_rf_data_S2_wd_s,
         rf_pred_abundance_2 = regr_rf_data_S2_wd_a,
         rf_pred_k_index_v = regr_rf_data_S2_v_k,
         rf_pred_shannon_v = regr_rf_data_S2_v_s,
         rf_pred_abundance_v = regr_rf_data_S2_v_a,
         brt_pred_k_index_2 = regr_brt_data_S2_wd_k,
         brt_pred_shannon_2 = regr_brt_data_S2_wd_s,
         brt_pred_abundance_2 = regr_brt_data_S2_wd_a,
         brt_pred_k_index_v = regr_brt_data_S2_v_k,
         brt_pred_shannon_v = regr_brt_data_S2_v_s,
         brt_pred_abundance_v = regr_brt_data_S2_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# TH4
data_TH4 <- cbind(regr_rf_data_TH4_wd_k, regr_rf_data_TH4_wd_s, regr_rf_data_TH4_wd_a, regr_rf_data_TH4_v_k, regr_rf_data_TH4_v_s, regr_rf_data_TH4_v_a, regr_brt_data_TH4_wd_k, regr_brt_data_TH4_wd_s, regr_brt_data_TH4_wd_a, regr_brt_data_TH4_v_k, regr_brt_data_TH4_v_s, regr_brt_data_TH4_v_a, TH4) |>
  rename(rf_pred_k_index_2 = regr_rf_data_TH4_wd_k,
         rf_pred_shannon_2 = regr_rf_data_TH4_wd_s,
         rf_pred_abundance_2 = regr_rf_data_TH4_wd_a,
         rf_pred_k_index_v = regr_rf_data_TH4_v_k,
         rf_pred_shannon_v = regr_rf_data_TH4_v_s,
         rf_pred_abundance_v = regr_rf_data_TH4_v_a,
         brt_pred_k_index_2 = regr_brt_data_TH4_wd_k,
         brt_pred_shannon_2 = regr_brt_data_TH4_wd_s,
         brt_pred_abundance_2 = regr_brt_data_TH4_wd_a,
         brt_pred_k_index_v = regr_brt_data_TH4_v_k,
         brt_pred_shannon_v = regr_brt_data_TH4_v_s,
         brt_pred_abundance_v = regr_brt_data_TH4_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance)

# VR3
data_VR3 <- cbind(regr_rf_data_VR3_wd_k, regr_rf_data_VR3_wd_s, regr_rf_data_VR3_wd_a, regr_rf_data_VR3_v_k, regr_rf_data_VR3_v_s, regr_rf_data_VR3_v_a, regr_brt_data_VR3_wd_k, regr_brt_data_VR3_wd_s, regr_brt_data_VR3_wd_a, regr_brt_data_VR3_v_k, regr_brt_data_VR3_v_s, regr_brt_data_VR3_v_a, VR3) |>
  rename(rf_pred_k_index_2 = regr_rf_data_VR3_wd_k,
         rf_pred_shannon_2 = regr_rf_data_VR3_wd_s,
         rf_pred_abundance_2 = regr_rf_data_VR3_wd_a,
         rf_pred_k_index_v = regr_rf_data_VR3_v_k,
         rf_pred_shannon_v = regr_rf_data_VR3_v_s,
         rf_pred_abundance_v = regr_rf_data_VR3_v_a,
         brt_pred_k_index_2 = regr_brt_data_VR3_wd_k,
         brt_pred_shannon_2 = regr_brt_data_VR3_wd_s,
         brt_pred_abundance_2 = regr_brt_data_VR3_wd_a,
         brt_pred_k_index_v = regr_brt_data_VR3_v_k,
         brt_pred_shannon_v = regr_brt_data_VR3_v_s,
         brt_pred_abundance_v = regr_brt_data_VR3_v_a,
         obs_k_index = k_index,
         obs_shannon = shannon,
         obs_abundance = abundance) 
```

### Results from Extraction 
```{r}
# bind results together 
# data_TH4 fehlt noch
regr_analysis <- rbind(data_GL1, data_GL2, data_L2, data_M1, data_S1, data_S2, data_TH4, data_VR3)

# export to .csv file
write.csv(regr_analysis, "Stat_Analysis/ml_regr_analysis.csv", row.names = FALSE)
```